






API — сокращение от Application Programming Interface (программный интерфейс приложения). API — набор правил, протоколов и инструментов для взаимодействия между приложениями. Говоря простым языком, API — интерфейс, который определяет, как одна программа должна взаимодействовать с другой программой. Как правило, представляет собой набор функций, которые могут быть вызваны другой программой.












GraphQL — язык запросов к API,позволяет пользователям API определять, какие данные им нужны в ответе. GraphQL API, в отличие от традиционного REST API, организуется по принципу полей и типов, а не эндпоинтов (запросов).

Одним из самых больших преимуществ GraphQL является его гибкость — он позволяет делать более точные запросы, определяя поля, которые вы хотите получить в ответе. Это особенно полезно, когда вы работаете с массивными API, которые содержат много данных. RETSful API часто возвращают больше данных, чем нужно клиенту. Бывают и обратные ситуации, когда нужно делать несколько запросов, чтобы получить все данные, которые нужны. GraphQL лишен этих недостатков.

Например, если вам нужно получить список всех названий всех треков всех альбомов какого-нибудь исполнителя с помощью REST API Spotify, вам нужно будет написать три запроса. Первым запросом вы получите ID исполнителя, вторым — все его альбомы, третьим — все треки в каждом альбоме. С помощью GraphQL API все эти данные можно получить с помощью одного запроса:















Что такое HTTP?
HTTP — сокращение от HyperText Transfer Protocol (протокол передачи гипертекста). Протокол используется для общения клиента и сервера. Клиентом, к примеру, может быть браузер (или в качестве клиента используется Postman).

После отправки клиентом HTTP-запроса, сервер возвращает ответ. Ответ сервера содержит метаданные о статусе и запрашиваемый контент.

Наиболее распространенные типы HTTP-запросов:

GET: GET-запросы используются для получения данных от API.
POST: POST-запросы используются для отправки новых данных API.
PUT: PUT-запросы используются для обновления уже существующих данных.
PATCH: PATCH-запросы (как и PUT) используются для обновления уже существующих данных. Разница в том, что с помощью PATCH запросов можно обновить несколько записей за раз.
DELETE: DELETE-запросы используются для удаления существующих данных.









JSON обьект

JSON обьект - НЕупорядоченное множество пар - "ключ": "значение"

{
"ключ": "значение",
"ключ": "значение",
"ключ": "значение",
"ключ": "значение"
} 

название_обьекта["ключ"]          достать из обьекта значение ключа
название_обьекта.ключ


Json массив

Json массив- это упорядоченное множество значений

[1, 'hello', 3]

название_массива[индекс элемента]       достать из массива значение 
название_массива[1]

массив начинается с [0] индекса элемента










XML 
(eXtensible Markup Language) — «расширяемый язык разметки»
XML — используется в SOAP (всегда) и REST-запросах (реже)
используется для хранения и передачи информации

вверху XML документа можно увидеть
<?xml version="1.0" encoding="UTF-8"?>
Эта строка называется XML прологом. Она показывает версию XML, который используется 
в документе, а также кодировку. Пролог необязателен, если его нет — это ок. 
Но если он есть, то это должна быть первая строка XML документа.
UTF-8 — кодировка XML документов по умолчанию.


В XML каждый элемент должен быть заключен в теги. 
Тег — это некий текст, обернутый в угловые скобки:
<tag>
Текст внутри угловых скобок — название тега.
Тега всегда два:
Открывающий — текст внутри угловых скобок
<tag>
Закрывающий — тот же текст (это важно!), но добавляется символ «/»
</tag>

В  XML-документе есть корневой элемент. Это тег, 
с которого документ начинается, и которым заканчивается. 

У элемента могут быть атрибуты — один или несколько. Их мы указываем внутри 
отрывающегося тега после названия тега через пробел в виде
название_атрибута = «значение атрибута»
Например:
<query attr1=“value 1”>Виктор Иван</query>
<query attr1=“value 1” attr2=“value 2”>Виктор Иван</query>









WSDL (Web Services Description Language ) простыми словами

язык описания веб-сервисов и доступа к ним, основанный на языке XML.

Язык описания Web-служб (WSDL) представляет собой стандартную спецификацию описания служб с поддержкой XML. Он предоставляет поставщикам служб простой способ описания базового формата запросов, передаваемых их системам, независимо от применяемой реализации.

Протоколы веб-сервисов
SOAP (Simple Object Access Protocol) — по сути это тройка стандартов SOAP/WSDL/UDDI
REST (Representational State Transfer)
XML-RPC (XML Remote Procedure Call)











Вкладка Body в Postman 
позволяет указать данные, которые необходимо отправить с запросом. Вы можете отправлять различные типы данных тела в соответствии с вашим API.
Если вы отправляете данные тела, убедитесь, что выбраны правильные заголовки, чтобы указать тип контента, который может потребоваться вашему API для правильной обработки полученных данных.
Для типов данных формы и URLencoded body Postman автоматически прикрепит правильный заголовок.
Если вы используете raw для данных body, Postman установит заголовок на основе выбранного вами типа (например, текст или json).
Если вы вручную выберете заголовок типа, он будет иметь приоритет над тем, что устанавливает Postman.
Postman не устанавливает тип заголовка для типа binary.
По умолчанию будет выбран тип none.

Form-data
Формы веб-сайтов часто отправляют данные в API как multipart/form-data. Вы можете воспроизвести это в Postman, используя вкладку Form-data / Body. Данные формы позволяют отправлять пары ключ-значение и указывать тип содержимого.

URL-encoded
Данные в URL-encoded используют ту же кодировку, что и параметры URL. Если для вашего API требуются данные в кодировке URL, выберите x-www-form-urlencoded на вкладке Body вашего запроса. Введите пары ключ-значение для отправки вместе с запросом, и Postman закодирует их перед отправкой. 

Raw
Используйте raw-данные ( необработанные данные тела) для отправки всего, что вы можете ввести в виде текста. Используйте вкладку raw и раскрывающийся список типов, чтобы указать формат, например: текст, JavaScript, JSON, HTML или XML. Таким образом Postman включит подсветку синтаксиса, а также добавит соответствующие заголовки к вашему запросу.

Binary
Вы можете использовать тип binary для отправки информации, которую нельзя ввести вручную в редакторе Postman вместе с телом запроса, например изображения, аудио- и видеофайлы. Вы также можете отправлять таким образом и текстовые файлы.

GraphQL
Вы можете отправлять запросы GraphQL, выбрав соответствующую вкладку. Введите свой код в области запросов и любые переменные в разделе GraphQL Variables.

Authorization: API используют авторизацию, чтобы убедиться, что клиент имеет доступ к запрашиваемым данным. В этой секции описываются параметры авторизации: например, username, password, bearer-токен и т.п.










Тестовый сценарий, связанный с коллекцией, будет запускаться после каждого запроса в коллекции.
Тестовый сценарий, связанный с папкой, будет запускаться после каждого прямого дочернего запроса в папке.













Newman — это средство запуска коллекций командной строки для Postman. Он позволяет запускать и тестировать коллекцию Postman прямо из командной строки. Он создан с учетом расширяемости, поэтому вы можете интегрировать его с серверами непрерывной интеграции (CI) и системами сборки.

Newman поддерживает равенство функций с Postman и позволяет запускать коллекции так, как они выполняются внутри средства запуска коллекций в Postman.

Newman – приложение, которое позволяет запускать и тестировать коллекцию Postman непосредственно из командной строки.

с помощью Newman Можно легко интегрировать наборы тестов в ваш любимый CI/CD инструмент  (CLI collection runner — позволяет запускать Postman-коллекции в командной строке)

коллекцию в newman можно запустить 2 способами:(через ссылку либо через локальный файл  коллекции)
newman run mycollection.json (json с коллекцией предварительно сохраняется на диске, можно добавить окружение через флаг -е)

либо в Postman генерируется ссылка на коллекцию (collection / share / via API)
newman run https://www.postman.com/collections/cb208e7e64056f5294e5 -e dev_environment.json

флаг -е укаывает на файл с окружением 






Коллекции (Collections)
Коллекции представляют собой группы запросов. Вы можете думать о коллекциях как о папках, в которых лежат запросы.

Коллекция может содержать любое число запросов. Запустить выполнение коллекции можно двумя способами:

с помощью Collection Runner
c помощью Newman








Окружение (Environments)
Окружения в Postman позволяют запускать запросы и коллекции, используя разные наборы данных. Например, мы можем создавать разные окружения в Postman для Dev, QA и Production серверов. В каждом из окружений будут свои собственные настройки: например, URL, auth token-ы и пароли, API-ключи и т.п. Окружения представляют собой наборы пар «ключ-значение».











SOAP


(Simple Object Access Protocol — простой протокол доступа к объектам)
протокол обмена структурированными сообщениями в распределённой вычислительной среде(наоснове XML).
	(SOAP — это формат обмена сообщениями.) 
	используется для обмена произвольными сообщениями в формате XML
	В SOAP вы используете формат SOAP XML для запросов и ответов.
	SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS
	Чаще всего SOAP используется поверх HTTP.
	SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и 
	доступа к ним, основанный на языке XML.
	
Использование SOAP для передачи сообщений увеличивает их объём и снижает скорость обработки

СТРУКТУРA ПРОТОКОЛА
	Envelope — корневой элемент, который определяет сообщение 
	и пространство имен, использованное в документе.

	Header — содержит атрибуты сообщения, например: информация 
	о безопасности или о сетевой маршрутизации

	Body — содержит сообщение, которым обмениваются приложения.

	Fault — необязательный элемент, который предоставляет 
	информацию об ошибках, которые произошли при обработке сообщений.


ПРИМЕР

SOAP-запрос

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetails xmlns="http://warehouse.example.com/ws">
       <productID>12345</productID>
     </getProductDetails>
   </soap:Body>
</soap:Envelope>

ОТВЕТ

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetailsResponse xmlns="http://warehouse.example.com/ws">
       <getProductDetailsResult>
         <productID>12345</productID>
         <productName>Стакан граненый</productName>
         <description>Стакан граненый. 250 мл.</description>
         <price>9.95</price>
         <currency>
             <code>840</code>
             <alpha3>USD</alpha3>
             <sign>$</sign>
             <name>US dollar</name>
             <accuracy>2</accuracy>
         </currency>
         <inStock>true</inStock>
       </getProductDetailsResult>
     </getProductDetailsResponse>
   </soap:Body>
</soap:Envelope>










REST 
(Representational State Transfer — «передача репрезентативного состояния» или передача состояния представления)
Архитектурный стиль ПО для распределенных систем, который, как првило, используется для построения веб-служб
АРХИТЕКТУРНЫЙ СТИЛЬ, КОТОРЫЙ ОПРЕДЕЛЯЕТ КАКИМИ СРЕДСТВАМИ БУДУТ ОБЩАТЬСЯ МЕЖДУ СОБОЙ СЕРВЕР И КЛИЕНТ

REST — это набор правил того, как программисту организовать написание кода серверного приложения, 
чтобы все системы легко обменивались данными и приложение можно было масштабировать.

REST API \ RESTful
это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.
REST - набор архитектурных принципов построения сервис-ориентированных систем.
RESTful - прилагательное, употребляющееся по отношению к сервисам, которые следуют принципам REST.

	REST поддерживает различный форматы XML. текстовые форматы
	работает только по протоколам HTTP и HTTPS
	в REST используется JSON
	может быть помещен в cash
	архитектурный стиль(нет огромного количества правил)
	быстрее SOAP
	занимает меньше места
	записывает информацию в более удобном (читаемом) виде










REST и SOAP сравнение

REST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.

Пример реализации RESTful: JSON через HTTP
Пример реализации SOAP: XML поверх SOAP через HTTP

На верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.

Специфика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML
Специфика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP — методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.

Формат обмена сообщениями
В SOAP вы используете формат SOAP XML для запросов и ответов.
В REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.

Определения услуг

SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.
REST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.

Транспорт

SOAP не накладывает никаких ограничений на тип транспортного протокола. Вы можете использовать либо Web протокол HTTP, либо MQ.

REST подразумевает наилучшее использование транспортного протокола HTTP

Простота реализации

RESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.

REST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.
Однако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.














HTTP (hyper text transfer protocol) 


протокол передачи данных (cами эти данные могут иметь другой формат, например, XML или JSON.),
изначально предназначен для передачи гиппертекстовой информации
протокол 
набор правил и законов покоторым будут передоваться данные

HTTPS (hyper text transfer protocol secure) 
протокол передачи информации конфеденциальность которой обеспечивается шифрованием информации

HTTP запрос, элементы

1	HTTP метод
2	путь к запрашиваему документу (URL)
3	версия HTTP
4	Headers  (заголовок), служебная информация
5	Тело запроса - опционально

HTTP ответ, элементы

1	Версия HTTP протокола
2	Статус код успешности операции
3	Status message (краткое описание кода состояния)
4	HTTP Headers (заголовки)
5	Тело ответа

response

GET / HTTP/1.1
Host: alizar.habrahabr.ru

request

HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive
Accept-Ranges: bytes











HTTP методы формирования запросов


Безопасные методы
не меняют состояние сервера, все безопасные методы являются идемпотентными

Идемпотентные методы
единичный и множественные вызовы этого метода, 
с идентичным набором данных, будут иметь тот же результат выполнения 
(без сторонних эффектов)

Кэшируемые методы
это HTTP-ответы, которые могут быть закешированы, то есть сохранены для 
дальнейшего восстановления и использования позже, тем самым снижая число 
запросов к серверу. Не все HTTP-ответы могут быть закешированы.

CRUD — акроним, обозначающий четыре базовые функции, используемые 
при работе с базами данных: создание (англ. create), чтение (read), модификация (update), удаление (delete). 
(в этом случае это GET. POST. PUT. DELETE.)

GET
Метод GET запрашивает представление ресурса. Запросы с использованием этого 
метода могут только извлекать данные.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Да
Безопасный			Да
Идемпотентный			Да
Кешируемый			Да
Допускается в HTML-формах	Да

Синтаксис
GET /index.html

HEAD
запрашивает ресурс так же, как и метод GET, но без тела ответа.
Такой запрос может быть выполнен перед загрузкой большого ресурса, 
например, для экономии пропускной способности.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Нет
Безопасный			Да
Идемпотентный			Да
Кешируемый			Да
Допускается в HTML-формах	Нет

Синтаксис
HEAD /index.html

POST
используется для отправки сущностей к определённому ресурсу. 
Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.

Запрос имеет тело		Да
Успешный ответ имеет тело	Да
Безопасный			Нет
Идемпотентный			Нет
Кешируемый			Только если включена информация о свежести сообщения
Допускается в HTML-формах	Да

Синтаксис
POST /index.html

PUT
заменяет все текущие представления ресурса данными запроса.
PUT содержится новая версия ресурса целиком.
Разница между PUT и POST в том, что PUT является идемпотентным,  в случае с POST, 
множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.

Запрос имеет тело		Да
Успешный ответ имеет тело	Нет
Безопасный			Нет
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
PUT /new.html HTTP/1.1

DELETE
удаляет указанный ресурс.

Запрос имеет тело		Может
Успешный ответ имеет тело	Может
Безопасный			Нет
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
DELETE /file.html HTTP/1.1

CONNECT
устанавливает "туннель" к серверу, определённому по ресурсу.
метод CONNECT может использоваться для доступа к сайту, который использует 
SSL (en-US) (HTTPS). Клиент запрашивает HTTP-прокси-сервер для туннелирования 
TCP-соединения с желаемым назначением. За тем сервер переходит к подключению 
от имени клиента. После того, как соединение установлено сервером, прокси-сервер 
продолжает проксировать поток TCP к клиенту и от него.

Синтаксис
CONNECT www.example.com:443 HTTP/1.1

OPTIONS
используется для описания параметров соединения с ресурсом.
Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) 
чтобы указать весь сервер целиком.

Запрос имеет тело		Нет
Успешный ответ имеет тело	Да
Безопасный			Да
Идемпотентный			Да
Кешируемый			Нет
Допускается в HTML-формах	Нет

Синтаксис
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1

TRACE
выполняет вызов возвращаемого тестового сообщения с ресурса.
выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.
Конечный получатель запроса должен отразить полученное сообщение, исключая 
некоторые поля описанные ниже, назад клиенту как тело сообщения с ответом 200 (OK) 
с заголовком Content-Type message/http. Конечный получатель это либо исходный сервер, 
либо первый сервер получивший значение Max-Forwards в запросе.

Синтаксис
TRACE /index.html

PATCH
используется для частичного изменения ресурса.
PATCH используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.

Иными словами, в PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс, находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии. А в PUT содержится новая версия ресурса целиком.











Cookies/cache



Cookies — это небольшие текстовые файлы у нас на компьютерах, в которых хранится информация о наших 
предыдущих действиях на сайтах. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть 
страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.
 
Кроме входов в аккаунты они умеют запоминать:
	предпочтения пользователей, например, язык, валюту или размер шрифта.
	товары, которые мы просматривали или добавили в корзину;
	текст, который мы вводили на сайте раньше;
	IP-адрес и местоположение пользователя;
	дату и время посещения сайта;
	версию ОС и браузера;
	клики и переходы

Временные (session storsge) (сессионные)- удаляются после закрытия браузера, существуют только во временной памяти

Постоянные (local storage) (следящие)- удаляются в определенную дату или через определенный промежуток времени
могут использоваться рекламодателями для записи о предпочтениях пользователя в течение длительного периода времени,
и еще чтобы избежать повторного ввода данных при каждом посещении сайта

Зомби-cookie  (или evercookie, или persistent cookie)- неудаляемые или трудно удаляемые cookie, 
которые можно восстановить в браузере с помощью JavaScript.
Зомби-cookie хранятся браузером в разных хранилищах, и при удалении только из одного хранилища 
система может восстановить этот файл из других хранилищ

Супер-cookie — это cookie-файл с источником домена верхнего уровня (например, .ru) 
или общедоступным суффиксом (например, .co.uk). Обычные cookie, напротив, имеют 
происхождение от конкретного доменного имени, например example.com.
Термин (супер-cookie) иногда используется для отслеживания технологий, которые не используют файлы cookie HTTP


CACHE
Кэш (cache) – это совокупность временных копий файлов программ, а также специально отведенное 
место их хранения для оперативного доступа. Соответственно, кэшированием называется 
процесс записи этих данных при работе операционной системы и отдельных программ.
временные файлы создаются для последующего их получения с большей скоростью

Аппаратный.  временные файлы записываются на само устройство в специально 
отведенные для этого участки памяти. Например, аппаратное кэширование в центральном процессоре 
выполняется в трех видах cache-памяти – L1, L2 и L3. Это позволяет программам быстро извлечь 
их при необходимости без обращения к иным устройствам в системе.

Программный. Кэширование этого типа осуществляется в выделенный участок памяти в 
операционной системе (как правило, он имеет вид обычной папки). Расположение кэша у 
различных программ может быть разным. Например, браузеры сохраняют свои временные файлы 
в свои папки в разделе Document and Settings.













Как работает веб-приложение
Повар раскатал тесто, выложил начинку, отправил пиццу в печь, упаковал в коробку для доставки. Так вот, коробка — это сайт, печь — веб-сервис, а повар — веб-приложение. Пицца, коробка, печь, повар — это не отдельные услуги, а часть единого процесса.

Перейдём от метафоры к реальности.

«Реализуем архитектуру “клиент-сервер”», — объявили разработчики. Что это значит: клиент только «просит» сервер поработать и выдать результат. Бизнес-процесс выполняется на сервере, а не на устройстве клиента. Веб-приложение — та часть кода на сервере, которая выполняет бизнес-процессы.

Веб-сервис(служба) — ещё более техническое понятие. Если веб-приложение хоть как-то касается клиента, то веб-сервис работает не с клиентом, а с другими приложениями и сервисами. Это код для другого кода.












 Postman-окружение/переменные
 
  – это просто коллекция переменных, которые можно использовать в коллекции Postman.

Поддерживаются следующие типы переменных:

Глобальные - переменные, которые не относятся ни к какому окружению, они доступны во всем рабочем пространстве, из всех окружений. Глобальные переменные могут использоваться для передачи данных между коллекциями, запросами и окружениями.
Переменные коллекции доступны во всех запросах внутри одной коллекции.
Переменные окружения изменяются в зависимости от выбранного окружения.
Локальные переменные являются временными. Они доступны только внутри запроса и используются, когда нужно переписать переменные коллекции или какие-то глобальные значения.
Переменные данных - файловые переменные.
Создаем файл с расширением csv или json. Postman поддерживает оба типа файлов, вопрос лишь в формате. 
В файле csv в первой строке указывается название переменной или нескольких переменных через запятую. Далее на отдельных строках следуют значения (или несколько значений через запятую).В файле json можно прописать то же самое, но в JSON-формате “ключ-значение”

иерархия переменных в Postman
Глобальные
коллекции
окружения
Локальные
данных

Глобальные переменные не могут иметь дубликаты. А вот локальные переменные могут иметь одни и те же имена, но только если они находятся в разных окружениях. Если Postman встречается с двумя переменными с одинаковыми именами, высший приоритет будет у локальной переменной

Postman использует библиотеку (https://www.npmjs.com/package/@faker-js/faker) переменных рандомных, можно использовать эти переменные, как и любую другую переменную в Postman. Их значения генерируются во время выполнения, а имена начинаются с $символа, например {{$guidили}} {{$timestamp}}.














postman interceptor

Postman Interceptor — это расширение для браузера, которое действует как дополнение к desctop приложению Postman. Interceptor позволяет перехватывать сетевые запросы и файлы cookie непосредственно из веб-браузера.

После установки расширения Interceptor вы можете запустить сеанс Interceptor , который представляет собой ограниченный по времени период захвата трафика. Вы можете приостановить, перезапустить и остановить сеанс Interceptor, а затем запустить другой. Каждый сеанс регистрируется на вкладке «История» и отображает общее время сеанса, обзор трафика и весь захваченный трафик. Вы также можете отправлять запросы и ответы в коллекцию и сохранять файлы cookie в банку файлов cookie Postman.








Переменная

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.
Для создания переменной в JavaScript используйте ключевое слово let.

let message;

Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания =

message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message




